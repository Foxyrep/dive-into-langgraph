## tests/graphiti 目录总体说明

本目录包含 3 个 Python Demo 脚本和 1 个 JSON 数据文件，主要用于演示：

- 如何用 LangChain 对已有 Neo4j 图谱做自然语言问答
- 如何用 Graphiti 将自然语言或结构化 JSON 数据写入 Neo4j 知识图谱

文件一览：

- Langchain_neo4j_demo.py
- best_demo.py
- best_demo_product.py
- 1218_json.json

---

## 一、技术栈概览

- 图数据库
  - Neo4j（Bolt 协议：bolt://...:7687）
- 大模型 / LLM 客户端
  - langchain_openai.ChatOpenAI（通过 SiliconFlow OpenAI 兼容接口）
  - graphiti_core.llm_client.OpenAIGenericClient / 自定义 SiliconFlowGenericClient
- LangChain 相关
  - langchain_neo4j.Neo4jGraph
  - langchain_neo4j.GraphCypherQAChain（自然语言 → Cypher → Neo4j）
- Graphiti 相关
  - graphiti_core.Graphiti（图谱写入 / 管理）
  - graphiti_core.llm_client.LLMConfig
  - graphiti_core.embedder.OpenAIEmbedder / OpenAIEmbedderConfig（Embedding 向量）
  - graphiti_core.cross_encoder.OpenAIRerankerClient（重排 / reranker）
  - graphiti_core.nodes.EntityNode
  - graphiti_core.edges.EntityEdge
  - graphiti_core.utils.maintenance.graph_data_operations.clear_data
- 数据模型
  - pydantic.BaseModel + Field：用于定义实体 / 关系的结构化 schema
- 数据文件
  - 1218_json.json：面料 / 产品相关的属性数据

---

## 二、分别实现了什么功能？

### 1. Langchain_neo4j_demo.py

- 使用 LangChain 的 GraphCypherQAChain：
  - 连接现有 Neo4j 图数据库（Neo4jGraph）
  - 刷新并加载数据库 schema（graph.refresh_schema()）
  - 使用 ChatOpenAI 作为 LLM
  - 将用户自然语言问题转换为 Cypher 查询
  - 执行查询并返回结果
- 提供交互式命令行界面：
  - 用户循环输入问题
  - 输入 "exit"/"quit"/"q" 退出

### 2. best_demo.py

- 使用 Graphiti 将一段“业务更新”文本写入图谱：
  - 定义实体类型：Person、Company、Product
  - 定义关系类型：Employment、Investment、Partnership
  - 定义实体到关系的映射 edge_type_map
  - 调用 graphiti.add_episode()：
    - name="Business Update"
    - episode_body 为一段自然语言描述
    - source_description="Business news"
    - reference_time=datetime.now()
    - 指定 entity_types、edge_types、edge_type_map
- Graphiti 与底层 LLM / embedding / reranker 配合，把 episode 中的信息抽取为实体 / 关系并存入 Neo4j。

### 3. best_demo_product.py

- 自定义 SiliconFlowGenericClient：
  - 继承 OpenAIGenericClient
  - 重写 _create_structured_completion，针对部分 response_model 返回固定的“空结构化结果”，以保证流程在结构化调用时不出错。
- 使用 Graphiti 处理 JSON 产品数据：
  - ingest_products：
    - 从 1218_json.json 读取 "products"
    - 每条记录映射到 Product(BaseModel)
    - 将其序列化为 JSON 字符串 episode_body
    - 通过 graphiti.add_episode() 以 EpisodeType.json 形式写入图谱
  - ingest_products_with_entities：
    - 与上类似先写入 episode
    - 构造一个 Product 类型的 EntityNode（labels=["Product"]）
    - 按字段列表（series、season_marking、dressing_category、fabric_erp、fun、className）：
      - 为每个非空字段值构造 ProductAttr 节点（labels=["ProductAttr"]）
      - 构造 HAS_ATTR 边（EntityEdge），并填入 created_at、fact 等
    - 调用 graphiti.add_triplet(product_node, edge, attr_node) 写入图谱
  - ingest_products_with_entities_concurrent：
    - 与 ingest_products_with_entities 逻辑一致
    - 使用 asyncio.Semaphore 控制并发度，实现并发导入
  - clear_graph_data：
    - 使用 clear_data(graphiti.driver) 清空图数据
  - main：
    - 调用 clear_graph_data() 清库
    - 预留了构建索引与并发导入的调用（目前注释掉）

---

## 三、实际效果概览

- Langchain_neo4j_demo.py
  - 可以对现有 Neo4j 图谱发起自然语言问答
  - LLM 自动生成 Cypher 查询，并执行在 Neo4j 上
  - verbose=True 时，可以看到生成的 Cypher 语句，便于调试与优化

- best_demo.py
  - 把一段“业务新闻 / 业务更新”描述转化为图谱中的实体和关系：
    - 例如 “Sarah 加入 TechCorp 担任 CTO，TechCorp 与 DataCorp 达成 500 万美金的合作”
    - 在图谱中表现为 Person / Company / Product 节点和 Employment / Investment / Partnership 等关系

- best_demo_product.py
  - 把 1218_json.json 中的产品数据批量写入 Neo4j 图谱：
    - 每个产品对应一个 Episode（方便追踪数据来源）
    - 以及一个 Product 节点，挂载多个 ProductAttr 节点
    - Product 通过 HAS_ATTR 关系连接多个属性节点（如系列、季节、穿着类别、功能等）
  - 提供清库与并发导入能力，方便做导入实验和压测。

---

## 四、各个类的职责梳理

### Langchain_neo4j_demo.py

本文件无自定义类，主要是以下函数：

- query_existing_graph()
  - 建立 Neo4jGraph 连接并刷新 schema
  - 初始化 ChatOpenAI（通过 SiliconFlow 接入）
  - 构建 GraphCypherQAChain 问答链
  - 启动命令行循环，接受用户问题并返回回答

### best_demo.py 中的类

> 这些类都是 Pydantic BaseModel，用于定义实体和关系的 schema，为 Graphiti 抽取和落库提供结构化描述。

- Person(BaseModel)
  - 说明：人物实体
  - 字段：age、occupation、location、birth_date 等
  - 用途：定义 Person 节点的可选属性

- Company(BaseModel)
  - 说明：公司 / 组织实体
  - 字段：industry、founded_year、headquarters、employee_count
  - 用途：定义 Company 节点的可选属性

- Product(BaseModel)
  - 说明：产品或服务实体
  - 字段：category、price、release_date
  - 用途：定义 Product 节点的可选属性（在该 demo 中作为扩展实体类型）

- Employment(BaseModel)
  - 说明：Person 与 Company 之间的雇佣关系
  - 字段：position、start_date、end_date、salary、is_current
  - 用途：定义 Employment 边上的属性

- Investment(BaseModel)
  - 说明：实体之间的投资关系
  - 字段：amount、investment_type、stake_percentage、investment_date
  - 用途：定义 Investment 边上的属性

- Partnership(BaseModel)
  - 说明：公司之间或人之间的合作关系
  - 字段：partnership_type、duration、deal_value
  - 用途：定义 Partnership 边上的属性

### best_demo_product.py 中的类

- SiliconFlowGenericClient(OpenAIGenericClient)
  - 说明：适配 SiliconFlow 的自定义 LLM 客户端
  - 覆写 _create_structured_completion：
    - 根据 response_model.__name__ 返回固定的“空结构化 JSON”
    - 确保 Graphiti 调用结构化推理接口时不会因为模型不支持而报错

- Product(BaseModel)
  - 说明：产品数据结构
  - 字段：
    - code：产品编码
    - weight：克重
    - elem：面料成分
    - inelem：内部组成说明
    - mprice：市场价
    - season_marking：季节标记
    - series：系列（可能是多个，用逗号分隔）
    - dressing_category：穿着类别
    - fun：功能性（如抗菌、拒水等）
    - fabric_erp：ERP 中的布种名称
    - className：布类名称
  - 用途：
    - 从 JSON 中读取后映射成 Product 对象
    - 用于生成 episode_body 和节点 attributes

---

## 五、图谱结构示意（节点 Label、关系类型、典型属性）

下面根据这几个 Demo 实际写入图谱时使用的 label、关系名称和属性，整理出结构示意。

### 1. best_demo.py：业务实体与关系

#### 节点（Nodes）

| Label   | 说明       | 典型属性示例                          |
|--------|------------|---------------------------------------|
| Person | 人物实体   | age, occupation, location, birth_date |
| Company| 公司实体   | industry, founded_year, headquarters, employee_count |
| Product| 产品实体   | category, price, release_date         |

> 注：Graphiti 内部还会有 Episode 等内部节点，但在本文件中我们显式定义和关注的是上述实体类型。

#### 关系（Edges）

| 关系类型      | 起点 Label | 终点 Label | 典型属性示例                            |
|--------------|-----------|-----------|-----------------------------------------|
| Employment   | Person    | Company   | position, start_date, end_date, salary, is_current |
| Investment   | Entity    | Entity    | amount, investment_type, stake_percentage, investment_date |
| Partnership  | Company   | Company   | partnership_type, duration, deal_value  |
| Partnership  | Person    | Person    | partnership_type, duration, deal_value  |

其中，edge_type_map 中定义的映射大致如下：

```text
Person --[Employment]--> Company
Company --[Partnership / Investment]--> Company
Person --[Partnership]--> Person
Entity --[Investment]--> Entity
```

> “Entity” 这里是抽象类型，Graphiti 内部会根据上下文判断具体的实体子类型。

### 2. best_demo_product.py：产品与属性结构

在产品导入 Demo 中，显式使用的节点和关系为：

#### 节点（Nodes）

| Label       | 说明                | 典型属性示例                                             |
|------------|---------------------|----------------------------------------------------------|
| Product    | 产品节点            | code, weight, elem, inelem, mprice, season_marking 等   |
| ProductAttr| 产品属性节点        | field（字段名）, value（字段值）                        |

ProductAttr 节点代表某个产品的某一类属性值，例如：

- name: "series:棉涤"
- attributes: {"field": "series", "value": "棉涤"}

#### 关系（Edges）

| 关系名称  | 起点 Label | 终点 Label | 典型属性示例                        |
|----------|-----------|-----------|-------------------------------------|
| HAS_ATTR | Product   | ProductAttr | group_id, created_at, fact 等      |

其中：

- group_id 固定为 "product_demo"（用于将本批数据归为一个组）
- fact 是一条自然语言形式的事实描述，例如：
  - "<产品 code> series 棉涤"
  - "<产品 code> season_marking 秋冬"

结构示意图：

```text
           +--------------------------+
           |        Product           |
           |  code, weight, ...       |
           +------------+-------------+
                        |
                        | HAS_ATTR
                        v
           +--------------------------+
           |      ProductAttr         |
           | field: "series"         |
           | value: "棉涤"           |
           +--------------------------+
```

对于一个产品，会有多条 HAS_ATTR 关系指向不同的属性节点，例如：

```text
(Product)-[:HAS_ATTR]->(ProductAttr {field:"series", value:"棉涤"})
(Product)-[:HAS_ATTR]->(ProductAttr {field:"season_marking", value:"秋冬"})
(Product)-[:HAS_ATTR]->(ProductAttr {field:"dressing_category", value:"T恤"})
...
```

### 3. Episode（文本 / JSON 事件）

虽然在本目录中没有直接定义 Episode 节点的类，但从以下调用可以知道实际写入时会存在 Episode 相关结构：

- best_demo.py:
  - graphiti.add_episode(name="Business Update", episode_body=..., ...)
- best_demo_product.py:
  - graphiti.add_episode(name=code 或 name, episode_body=..., source=EpisodeType.json, ...)

Graphiti 通常会：

- 为每次 add_episode 创建一条 Episode 记录
- 将 Episode 和抽取出的 Entity / Edge 关联起来（具体实现细节在 graphiti_core 内部）

从“实际落库结构”的角度，至少可以认为每次导入会新增：

- 1 条 Episode 记录（内部可能为一个或多个节点/关系）
- 若使用 add_triplet，则显式新增：
  - 1 个源节点（如 Product）
  - 1 个目标节点（如 ProductAttr）
  - 1 条关系（HAS_ATTR）

---

以上是对 tests/graphiti 目录下各个类、功能以及在 Neo4j 中实际落库结构的汇总说明，可作为后续建模、查询和优化图谱结构时的参考文档。

